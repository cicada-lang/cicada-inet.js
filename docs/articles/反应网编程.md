---
title: 反应网编程
author: 谢宇恒
year: 2023
---

# 1

2021 年末，我偶然看到一片 1990 年的论文 Interaction Nets，
作者是法国逻辑学家拉丰 Yves Lafont。
其中介绍了一种很新奇的计算模型，
用节点和边组成的图作为数据，
用相邻节点之间的反应作为计算。

节点之间的反应让人想到化学反应，
所以 Interaction 一词，我翻译为反应，
整个计算模型就称作反应网。

# 2

如何用图来编码数据呢？

假设我们要编码最简单的数据 -- 自然数，
我们可以模仿上古结绳计数，用节点来记录个数。

```
0  (zero)--
1  (zero)--(add1)--
2  (zero)--(add1)--(add1)--
3  (zero)--(add1)--(add1)--(add1)--
```

代表 0 的节点 `(zero)` 有一个接口，
代表 +1 的节点 `(add1)` 有两个接口，
将这些节点按照接口连接起来，就能编码自然数。

# 3

如何用图来表示作用于自然数的函数呢？

以加法为例，我们需要引入一个新的节点来代表加法，
并且定义这个节点与其他节点之间的反应规则。

用一个有三个接口的节点表示加法。

```
       |
     (add)
     /   \
```

下面两个接口代表输入的 `被加数` 与 `加数`，
上面一个接口代表输出的 `得数`。

```
      得数
       |
     (add)
     /   \
 被加数  加数
```

比如 0 + 1 可以表示如下：

```
       |
     (add)
     /   \
(zero)   (add1)
           |
         (zero)
```

2 + 2 可以表示如下：

```
       |
     (add)
     /   \
(add1)   (add1)
  |        |
(add1)   (add1)
  |        |
(zero)   (zero)
```

通过定义 `(add)` 与相邻节点之间的反应方式，就可以完成加法的操作。

当 `(add)` 的 `被加数` 接口与 `(zero)` 相连时，
删除 `(zero)` 与 `(add)`，
并将 `(add)` 的 `得数` 接口与 `加数` 接口直接相连，
反应的规则如下：

```
      得数            得数
       |               |
     (add)     =>      |
     /   \              \
(zero)   加数           加数
```

当 `(add)` 的 `被加数` 接口与 `(add1)` 相连时，
将 `(add1)` 转移到 `(add)` 上方，
反应的规则如下：

```
      得数            得数
       |               |
     (add)     =>    (add1)
     /   \             |
(add1)   被加数       (add)
  |                  /   \
前数               前数  被加数
```

按照这两个规则，表示 2 + 2 的图，将通过如下的反应而得到 4：

```
       |                  |                 |            |
     (add)              (add1)            (add1)       (add1)
     /   \                |                 |            |
(add1)   (add1)         (add)             (add1)       (add1)
  |        |    =>      /   \      =>       |       =>   |
(add1)   (add1)    (add1)   (add1)        (add)        (add1)
  |        |         |        |           /   \          |
(zero)   (zero)    (zero)   (add1)   (zero)   (add1)   (add1)
                              |                 |        |
                            (zero)            (add1)   (zero)
                                                |
                                              (zero)
```

# 4

我们来设计一个程序语言，以实践上面所描述的计算模型。

在我们的语言中，每个节点都有固定数量的接口。

```
(zero) // 有一个接口
(add1) // 有两个接口
(add)  // 有三个接口
```

每个接口都有名字。

```
(zero)-value  // 0 这个值

(add1)-prev   // 前一个数
(add1)-value  // +1 所得的值

(add)-target  // 被加数
(add)-addend  // 加数
(add)-return  // 得数
```

接口分为两类，一类是输入接口，一类是输出接口。

```
-------------
(zero)-value   // 输出接口

(add1)-prev    // 输入接口
-------------
(add1)-value   // 输出接口

(add)-target   // 输入接口
(add)-addend   // 输入接口
-------------
(add)-return   // 输出接口
```

节点和节点之间可以通过接口相连，并且输入接口只能与输出接口相连。

比如代表数字 2 的图：

```
(zero)--(add1)--(add1)--
```

其接口具体的连接方式是：

```
(zero)-value prev-(add1)
(add1)-value prev-(add1)
(add1)-value // 未连接的自由节点
```

每个节点都有唯一一个主接口，
只有当两个节点的主接口相连，
才可以根据规则进行反应。

```
-------------
(zero)-value!   // 主接口

(add1)-prev
-------------
(add1)-value!   // 主接口

(add)-target!   // 主接口
(add)-addend
-------------
(add)-return
```

另外我们要求每个接口都有固定的类型，
只有类型相互匹配的接口才能相连。

我们设计定义节点的语句如下：

- 以 `node` 作为语句的开头，后面跟着节点的名字，`end` 做结尾。
- 用一条分割线区分输入接口与输出接口。
  - 分割线前面的是输入接口。
  - 分割线后面的是输出接口。
  - 分割线写多长都可以，最短要求两个字符 `--`。
- 接口的名字作为标签写在类型之后。
- 主接口加 `!` 后缀。

假设代表自然数的类型是 `Nat`，
前文提到的节点定义如下：

```
node zero
  --------
  Nat :value!
end

node add1
  Nat :prev
  --------
  Nat :value!
end

node add
  Nat :target!
  Nat :prev
  --------
  Nat :return
end
```

# 5

类型是有可能带有其他类型参数的，
其实目前我们所需要的信息只是类型的输入参数个数，
因为类型输入的一定是类型，输出的也一定是类型。

但是为了与节点的定义保持一致，
我们设计定义类型的语句如下：

- 以 `type` 作为语句的开头，后面跟着类型的名字，`end` 做结尾。
- 用一条分割线区分输入参数与输出参数。
  - 分割线前面的是输入类型参数，只能是 `Type`。
  - 分割线后面的是输出类型参数，只能是一个 `Type`。
  - 分割线写多长都可以，最短要求两个字符 `--`。

比如，代表自然数的类型 `Nat` 没有输入类型参数，其定义是：

```
type Nat -- Type end
```

又比如链表 `List` 有一个输入类型参数，
代表链表元素的类型，
其定义是：

```
type List Type -- Type end
```

# 6

针对指定的两个节点，可以定义反应规则。

带着接口的英文名字，回顾看一下
`(add1)` 和 `(add)` 之间的反应规则：

```
     return          value
       |               |
     (add)     =>    (add1)
     /   \             |
(add1)   addend      (add)
  |                  /   \
prev            target   addend
```

我们发现所谓反应，其实就是：

- 拆掉两个主接口之间的边。
- 拆掉规则所匹配到的两个节点，此时会暴露出来原本与这两个节点相连的接口。
- 将暴露出来的接口重新连接，在这个过程中可以引入新的节点。

我们设计定义规则的语句如下：

- 以 `rule` 作为语句的开头，后面跟着两个节点的名字，`end` 做结尾。
- 用一个栈，作为临时放置接口的辅助区域。
- 用 `(node)-port` 这个词组，
  引用由于拆掉某一节点的某一接口而暴露出来的接口，
  并且将这个接口放到栈里。
- 用 `port-(node)` 这个词组，
  同样引用因拆而暴露出来的接口，
  并且将这个接口与栈顶的接口相连。
- 用 `(node)` 这个词组，通过节点的名字引用节点，
  并且按顺序取此节点的输入接口与栈顶的接口相连，
  每一个输入接口会用掉栈中的一个接口，
  然后将此节点的输出接口按顺序放回栈中。

以 `(add1)` 与 `(add)` 之间的规则为例：

```
rule add1 add
  (add)-addend
  (add1)-prev add
  add1 return-(add)
end
```

下面逐步分析在上面的定义中，
每一个词作用之后栈的情况，
以及调用节点时新产生的节点与新产生的连接。

- 由调用节点名字而引入的新节点，加脚标以示是区分。
- 注意，不带角标的 `(add)-addend`
  并非代表 `(add)` 的接口 `addend`，
  而是代表由于在原图中拆掉 `(add)` 的接口 `addend`
  而暴露出来的对应接口。

```
  栈：[ ]

(add)-addend

  栈：[ (add)-addend ]

(add1)-prev

  栈：[ (add)-addend, (add1)-prev ]

add

  新节点：(add₂)

  新连接：
    (add1)-prev target-(add₂)
    (add)-addend addend-(add₂)

  栈：[ (add₂)-return ]

add1

  新节点：(add1₂)

  新连接：
    (add₂)-return prev-(add1₂)

  栈：[ (add1₂)-value ]

return-(add)

  栈：[ ]
```

`(zero)` 与 `(add)` 之间的规则较为特殊，
因为在重新连接所暴露出来的接口时，
没有引入新的节点。

```
rule zero add
  (add)-addend
  return-(add)
end
```

# 7

综合上面所设计的语法关键词，完整的一段代码如下。

在其中，我们还用了 `define` 来定义新词。
在使用 `define` 做定义之前，必须先用 `claim` 来声明一个词的类型。

我们还有一个线上的演算场，可以用来方便地分享代码。

[去 Nat 与 `(add)` 的演算场](https://inet.run/playground/dHlwZSBOYXQgLS0gVHlwZSBlbmQKCm5vZGUgemVybwogIC0tLS0tLS0tLS0tLQogIE5hdCA6dmFsdWUhCmVuZAoKbm9kZSBhZGQxCiAgTmF0IDpwcmV2CiAgLS0tLS0tLS0tLS0tCiAgTmF0IDp2YWx1ZSEKZW5kCgpub2RlIGFkZAogIE5hdCA6dGFyZ2V0IQogIE5hdCA6YWRkZW5kCiAgLS0tLS0tLS0tLS0tCiAgTmF0IDpyZXR1cm4KZW5kCgpydWxlIHplcm8gYWRkCiAgKGFkZCktYWRkZW5kCiAgcmV0dXJuLShhZGQpCmVuZAoKcnVsZSBhZGQxIGFkZAogIChhZGQpLWFkZGVuZAogIChhZGQxKS1wcmV2IGFkZAogIGFkZDEgcmV0dXJuLShhZGQpCmVuZAoKY2xhaW0gb25lIC0tIE5hdCBlbmQKCmRlZmluZSBvbmUKICB6ZXJvIGFkZDEKZW5kCgpjbGFpbSB0d28gLS0gTmF0IGVuZAoKZGVmaW5lIHR3bwogIG9uZSBhZGQxCmVuZAoKY2xhaW0gYWRkX3R3byBOYXQgLS0gTmF0IGVuZAoKZGVmaW5lIGFkZF90d28KICB0d28gYWRkCmVuZAoKb25lIGFkZF90d28Kb25lIGFkZF90d28KYWRk)

```
type Nat -- Type end

node zero
  ------------
  Nat :value!
end

node add1
  Nat :prev
  ------------
  Nat :value!
end

node add
  Nat :target!
  Nat :addend
  ------------
  Nat :return
end

rule zero add
  (add)-addend
  return-(add)
end

rule add1 add
  (add)-addend
  (add1)-prev add
  add1 return-(add)
end

claim one -- Nat end

define one
  zero add1
end

claim two -- Nat end

define two
  one add1
end

claim add_two Nat -- Nat end

define add_two
  two add
end

one add_two
one add_two
add
```

# 8

我们强调一下反应网的限制，
以及由于这些限制而得到的，
反应网作为计算模型的属性。

第一个限制是，对于两个节点，最多只能定义一条反应规则。

也就是说，当发现两个节点的主接口相连时，
要么找不到这两个节点所对应的规则，此时这两个节点不能反应；
要么只能找到唯一一条规则，这两个节点按照这条规则反应。

这个限制排除了，能找到两条规则，而需要做选择的情况。

第二个限制是，每个节点有且仅有一个主接口。

假设有两个节点的主接口相连了，
我们画一个圈把这两个节点还有主接口之间的边都圈起来，
由于这两个节点都只有一个主接口，
所以能跨过这个圈的都是普通接口之间的边，
这些边是不能反应的。

```
     \   |   /
  .-------------.
  |    \ | /    |
  |   (.....)   |
  |      |      |
  |   (.....)   |
  |    / | \    |
  `-------------`
     /   |   \
```

所以即便这两个节点之间的一次反应可能引入新的节点，
以及新的可反应的边，但是所有新的可反应边都会在这个圈子之内，
反应过程中的拆除与重连都不会影响到图的其他部分。

也就是说，在反应网这个计算模型中，
反应都是相互独立的，先在这里反应，或者先在那里反应，
不会影响最终的计算结果。

如果忽略不同位反应进行的先后，
那么在反应网中，
不光计算的结果是唯一的，
计算的过程也是唯一的！

在实现反应网时，如果计算机有多个内核，
我们可以开多个线程，共享同一段内存，
同时进行图中不同位置的反应，
这些线程之间也不会相互干扰。

# 9

每个节点有且仅有一个主接口，
这条限制，给计算模型带来了优越的属性，
但是它也使得我们在用这个计算模型编程时不那么方便了。

取两个自然数最大值的函数就是一个例子，
我们称代表这个函数的节点为 `(max)`。

```
     return
       |
     (max)
     /    \
first!   second
```

定义如下：

```
node max
  Nat :first!
  Nat :second
  ----------
  Nat :return
end
```

`(zero)` 与 `(zero)` 的反应很简单：

```
     return         return
       |              |
     (max)      =>    |
     /    \            \
(zero)   second       second
```

定义如下：

```
rule zero max
  (max)-second return-(max)
end
```

如果没有单主接口的限制，
对于 `(add1)` 与 `(zero)` 的反应，
我们完全可以想象下面的反应规则：

```
     return           return
       |                |
     (max)      =>    (add1)
     /    \             |
(add1)    (add1)      (max)
   |        |         /   \
 prev      prev    prev   prev
```

但是，由于单主接口的限制，
我们不得不增加一个辅助节点以及相关的规则，
来明显地在两个可反应的边中做出选择。

我们称辅助节点为 `(max_aux)`，
其中 `aux` 是 auxiliary 的所写。

```
     return
       |
   (max_aux)
     /    \
first    second!
```

定义如下：

```
node max_aux
  Nat :first
  Nat :second!
  --------
  Nat :return
end
```

利用辅助节点定义 `(add1)` 和 `(max)` 之间的规则：

```
     return            return
       |                 |
     (max)      =>   (max_aux)
     /    \            /   \
(add1)   second     prev   second
   |
 prev
```

定义如下：

```
rule add1 max
  (max)-second
  (add1)-prev max_aux
  return-(max)
end
```

`(zero)` 与 `(max_aux)` 之间的规则：

```
     return            return
       |                 |
   (max_aux)     =>    (add1)
     /    \              |
 first   (zero)        first
```

定义如下：

```
rule zero max_aux
  (max_aux)-first add1
  return-(max_aux)
end
```

`(add1)` 与 `(max_aux)` 之间的规则：

```
     return            return
       |                 |
   (max_aux)     =>    (add1)
     /    \              |
 first   (add1)        (max)
           |           /   \
          prev     first   prev
```

定义如下：

```
rule add1 max_aux
  (add1)-prev
  (max_aux)-first max
  add1 return-(max_aux)
end
```

[去 Nat 与 `(max)` 的演算场](https://inet.run/playground/dHlwZSBOYXQgLS0gVHlwZSBlbmQKCm5vZGUgemVybwogIC0tLS0tLQogIE5hdCA6dmFsdWUhCmVuZAoKbm9kZSBhZGQxCiAgTmF0IDpwcmV2CiAgLS0tLS0tLS0tLQogIE5hdCA6dmFsdWUhCmVuZAoKLy8gVG8gZGVmaW5lIGBtYXhgLCB3ZSBuZWVkIGBtYXhfYXV4YC4KCm5vZGUgbWF4X2F1eAogIE5hdCA6Zmlyc3QKICBOYXQgOnNlY29uZCEKICAtLS0tLS0tLQogIE5hdCA6cmV0dXJuCmVuZAoKbm9kZSBtYXgKICBOYXQgOmZpcnN0IQogIE5hdCA6c2Vjb25kCiAgLS0tLS0tLS0tLQogIE5hdCA6cmV0dXJuCmVuZAoKcnVsZSB6ZXJvIG1heAogIChtYXgpLXNlY29uZCByZXR1cm4tKG1heCkKZW5kCgpydWxlIGFkZDEgbWF4CiAgKG1heCktc2Vjb25kIChhZGQxKS1wcmV2IG1heF9hdXgKICByZXR1cm4tKG1heCkKZW5kCgpydWxlIHplcm8gbWF4X2F1eAogIChtYXhfYXV4KS1maXJzdCBhZGQxCiAgcmV0dXJuLShtYXhfYXV4KQplbmQKCnJ1bGUgYWRkMSBtYXhfYXV4CiAgKGFkZDEpLXByZXYgKG1heF9hdXgpLWZpcnN0IG1heAogIGFkZDEgcmV0dXJuLShtYXhfYXV4KQplbmQKCmNsYWltIG9uZSAtLSBOYXQgZW5kCmRlZmluZSBvbmUgemVybyBhZGQxIGVuZAoKY2xhaW0gdHdvIC0tIE5hdCBlbmQKZGVmaW5lIHR3byBvbmUgYWRkMSBlbmQKCmNsYWltIHRocmVlIC0tIE5hdCBlbmQKZGVmaW5lIHRocmVlIHR3byBhZGQxIGVuZAoKY2xhaW0gZm91ciAtLSBOYXQgZW5kCmRlZmluZSBmb3VyIHRocmVlIGFkZDEgZW5kCgp6ZXJvIHR3byBtYXgKCnRocmVlIHR3byBtYXg)

```
type Nat -- Type end

node zero
  ------
  Nat :value!
end

node add1
  Nat :prev
  ----------
  Nat :value!
end

// To define `max`, we need `max_aux`.

node max_aux
  Nat :first
  Nat :second!
  --------
  Nat :return
end

node max
  Nat :first!
  Nat :second
  ----------
  Nat :return
end

rule zero max
  (max)-second return-(max)
end

rule add1 max
  (max)-second (add1)-prev max_aux
  return-(max)
end

rule zero max_aux
  (max_aux)-first add1
  return-(max_aux)
end

rule add1 max_aux
  (add1)-prev (max_aux)-first max
  add1 return-(max_aux)
end

claim one -- Nat end
define one zero add1 end

claim two -- Nat end
define two one add1 end

claim three -- Nat end
define three two add1 end

claim four -- Nat end
define four three add1 end

zero two max

three two max
```

# TODO

`nat_erase`, `nat_dup` -- 零返回值和多返回值。
